void
fastuidraw_gl_brush_main(in uint sub_shader,
                         inout uint shader_data_offset,
                         inout vec2 brush_location,
                         inout vec4 color)
{
  vec2 q, index_coord, texel_coord, image_xy, image_loc;
  int color_layer;
  uint image_filter;
  vec4 image_color;
  fastuidraw_image_data image;
  float image_factor;

  shader_data_offset = fastuidraw_read_image_data(shader_data_offset, image);
  image_filter = image.image_filter;

  /* fract the brush coordinate to the size of the image.
     TODO: support different wrap modes.
  */
  q = mod(brush_location, vec2(image.image_size));

  /* convert from image coordinates to index-tile coordinates
   */
  image_factor = 1.0 / float(image.image_size_over_master_size);
  image_loc = image.master_index_tile_atlas_location_xyz.xy + vec2(image.image_start) * image_factor;
  image_xy = q * image_factor + image_loc;

  /* lookup the texel coordinate in the large atlas from the index-tile
     coordinate.
  */
  fastuidraw_brush_compute_image_atlas_coord(image_xy, int(image.master_index_tile_atlas_location_xyz.z),
                                             int(image.number_index_lookups),
                                             int(image.slack),
                                             texel_coord, color_layer);

  if(image_filter == uint(fastuidraw_image_filter_nearest))
    {
      image_color = texelFetch(fastuidraw_imageAtlas, ivec3(texel_coord, color_layer), 0).rgba;
    }
  else if(image_filter == uint(fastuidraw_image_filter_linear))
    {
      image_color = texture(fastuidraw_imageAtlasFiltered,
                            vec3(texel_coord * fastuidraw_imageAtlas_size_reciprocal, color_layer)).rgba;
    }
  else
    {
      /* Cubic filtering by realizing cubic-filtering as repeated
         bilinear filtering, see GPU Gems 2, Chapter 20.
         Code inspired by StackOverflow (http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl)
         and from Shiny Pixels (http://vec3.ca/bicubic-filtering-in-fewer-taps/)
      */
      vec2 fract_texel_coord, linear_weight;
      vec4 x_weights, y_weights;
      vec4 corner_coords, weight_sums, texture_coords;
      vec4 t00, t10, t01, t11;

      texel_coord -= vec2(0.5, 0.5);
      fract_texel_coord = fract(texel_coord);
      texel_coord -= fract_texel_coord;

      x_weights = fastuidraw_brush_cubic_weights(fract_texel_coord.x);
      y_weights = fastuidraw_brush_cubic_weights(fract_texel_coord.y);

      corner_coords = vec4(texel_coord.x - 0.5, texel_coord.x + 1.5,
                           texel_coord.y - 0.5, texel_coord.y + 1.5);
      weight_sums = vec4(x_weights.x + x_weights.y, x_weights.z + x_weights.w,
                         y_weights.x + y_weights.y, y_weights.z + y_weights.w);

      texture_coords = corner_coords + vec4(x_weights.y, x_weights.w, y_weights.y, y_weights.w) / weight_sums;
      texture_coords *= fastuidraw_imageAtlas_size_reciprocal.xyxy;

      t00 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.xz, color_layer));
      t10 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.yz, color_layer));
      t01 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.xw, color_layer));
      t11 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.yw, color_layer));

      linear_weight.x = weight_sums.y / (weight_sums.x + weight_sums.y);
      linear_weight.y = weight_sums.w / (weight_sums.z + weight_sums.w);

      image_color = mix(mix(t00, t10, linear_weight.x),
                        mix(t01, t11, linear_weight.x),
                        linear_weight.y);
    }

  color *= image_color;
}

vec4
fastuidraw_brush_cubic_weights(float x)
{
    float x_squared = x * x;
    float x_cubed = x_squared * x;
    float one_minus_x = 1.0 - x;
    float one_minus_x_squared = one_minus_x * one_minus_x;
    float one_minus_x_cubed = one_minus_x_squared  * one_minus_x;
    vec4 w;

    w.x = one_minus_x_cubed;
    w.y = 3.0 * x_cubed - 6.0 * x_squared + 4.0;
    w.z = 3.0 * one_minus_x_cubed - 6.0 * one_minus_x_squared + 4.0;
    w.w = x_cubed;
    return w / 6.0;
}

void
fastuidraw_brush_compute_image_atlas_coord(in vec2 image_shader_coord,
                                          in int index_layer,
                                          in int num_lookups,
                                          in int slack,
                                          out vec2 image_atlas_coord,
                                          out int image_atlas_layer)
{
  /* this seams silly, but there is a reason.
     On Mesa/i965 (as of Oct 23, 2015) without this wrapper,
     the GLSL compiler produces an incorrect shader that
     fails for the case where num_lookups is one.
     However, making the case of 1 explicit makes this
     thing work.
   */
  if(num_lookups == 1)
    {
      fastuidraw_compute_image_atlas_coord(image_shader_coord, index_layer,
                                          1, slack,
                                          image_atlas_coord,
                                          image_atlas_layer);
    }
  else
    {
      fastuidraw_compute_image_atlas_coord(image_shader_coord, index_layer,
                                          num_lookups, slack,
                                          image_atlas_coord,
                                          image_atlas_layer);
    }
}

void
fastuidraw_brush_const_color(inout uint shader_data_offset,
                             inout vec4 color)
{
  vec4 pen_color;
  shader_data_offset = fastuidraw_read_pen_color(shader_data_offset, pen_color);
  color *= pen_color;
}

void
fastuidraw_brush_linear_gradient(inout uint shader_data_offset,
                                 in vec2 brush_location,
                                 inout vec4 color)
{
  fastuidraw_linear_gradient linear_gradient;
  vec2 v, d;
  float t;

  shader_data_offset = fastuidraw_read_linear_gradient(shader_data_offset, linear_gradient);

  v = linear_gradient.end_pt - linear_gradient.start_pt;
  d = brush_location - linear_gradient.start_pt;
  t = dot(v, d) / dot(v, v);
  if((linear_gradient.flags & uint(fastuidraw_linear_gradient_repeat_mask)) != 0u)
    {
      t = fract(t);
    }
  t = linear_gradient.color_stop_sequence_xy.x + t * linear_gradient.color_stop_sequence_width;
  color *= fastuidraw_colorStopFetch(t, linear_gradient.color_stop_sequence_xy.y);
}

void
fastuidraw_brush_radial_gradient(inout uint shader_data_offset,
                                 in vec2 brush_location,
                                 inout vec4 color)
{
  fastuidraw_radial_gradient radial_gradient;
  vec2 q, delta_p;
  float delta_r, a, b, c, desc, t0, t1, recip_two_a, t;

  shader_data_offset = fastuidraw_read_radial_gradient(shader_data_offset, radial_gradient);
  q = brush_location - radial_gradient.start_pt;
  delta_p = radial_gradient.end_pt - radial_gradient.start_pt;
  delta_r = radial_gradient.end_r - radial_gradient.start_r;

  c = dot(q, q) - radial_gradient.start_r * radial_gradient.start_r;
  b = 2.0 * (dot(q, delta_p) - radial_gradient.start_r * delta_r);
  a = dot(delta_p, delta_p) - delta_r * delta_r;

  desc = b * b - 4.0 * a * c;
  if(desc < 0.0)
    {
      color = vec4(0.0, 0.0, 0.0, 0.0);
    }
  else
    {
      desc = sqrt(abs(desc));
      recip_two_a = 0.5 / a;
      t0 = (-b + desc) * recip_two_a;
      t1 = (-b - desc) * recip_two_a;

      /* if both t0 and t1 are in range, then take the max
         if both t0 and t1 are not in range, then take max
         if only one of t0 and t1 are in range take that one.
      */

      /* G.x is 1 exactly when t0 is in range
         G.y is 1 exactly when t1 is in range
      */
      vec2 G;
      G = step(0.0, vec2(t0, t1)) * step(vec2(t0, t1), vec2(1.0, 1.0));
      t = (G.x == G.y) ? max(t0, t1) : dot(G, vec2(t0, t1));
      if((radial_gradient.flags & uint(fastuidraw_radial_gradient_repeat_mask)) != 0u)
        {
          t = fract(t);
        }
      t = radial_gradient.color_stop_sequence_xy.x + t * radial_gradient.color_stop_sequence_width;
      color *= fastuidraw_colorStopFetch(t, radial_gradient.color_stop_sequence_xy.y);
    }
}

void
fastuidraw_brush_image(inout uint shader_data_offset,
                       in vec2 brush_location,
                       inout vec4 color)
{
  vec2 q, index_coord, texel_coord, image_xy, image_loc;
  int color_layer;
  uint image_filter;
  vec4 image_color;
  fastuidraw_image_data image;
  float image_factor;

  shader_data_offset = fastuidraw_read_image_data(shader_data_offset, image);
  image_filter = image.image_filter;

  /* fract the brush coordinate to the size of the image.
     TODO: support different wrap modes.
  */
  q = mod(brush_location, vec2(image.image_size));

  /* convert from image coordinates to index-tile coordinates
   */
  image_factor = 1.0 / float(image.image_size_over_master_size);
  image_loc = image.master_index_tile_atlas_location_xyz.xy + vec2(image.image_start) * image_factor;
  image_xy = q * image_factor + image_loc;

  /* lookup the texel coordinate in the large atlas from the index-tile
     coordinate.
  */
  fastuidraw_brush_compute_image_atlas_coord(image_xy, int(image.master_index_tile_atlas_location_xyz.z),
                                             int(image.number_index_lookups),
                                             int(image.slack),
                                             texel_coord, color_layer);

  if(image_filter == uint(fastuidraw_image_filter_nearest))
    {
      image_color = texelFetch(fastuidraw_imageAtlas, ivec3(texel_coord, color_layer), 0).rgba;
    }
  else if(image_filter == uint(fastuidraw_image_filter_linear))
    {
      image_color = texture(fastuidraw_imageAtlasFiltered,
                            vec3(texel_coord * fastuidraw_imageAtlas_size_reciprocal, color_layer)).rgba;
    }
  else
    {
      /* Cubic filtering by realizing cubic-filtering as repeated
         bilinear filtering, see GPU Gems 2, Chapter 20.
         Code inspired by StackOverflow (http://stackoverflow.com/questions/13501081/efficient-bicubic-filtering-code-in-glsl)
         and from Shiny Pixels (http://vec3.ca/bicubic-filtering-in-fewer-taps/)
      */
      vec2 fract_texel_coord, linear_weight;
      vec4 x_weights, y_weights;
      vec4 corner_coords, weight_sums, texture_coords;
      vec4 t00, t10, t01, t11;

      texel_coord -= vec2(0.5, 0.5);
      fract_texel_coord = fract(texel_coord);
      texel_coord -= fract_texel_coord;

      x_weights = fastuidraw_brush_cubic_weights(fract_texel_coord.x);
      y_weights = fastuidraw_brush_cubic_weights(fract_texel_coord.y);

      corner_coords = vec4(texel_coord.x - 0.5, texel_coord.x + 1.5,
                           texel_coord.y - 0.5, texel_coord.y + 1.5);
      weight_sums = vec4(x_weights.x + x_weights.y, x_weights.z + x_weights.w,
                         y_weights.x + y_weights.y, y_weights.z + y_weights.w);

      texture_coords = corner_coords + vec4(x_weights.y, x_weights.w, y_weights.y, y_weights.w) / weight_sums;
      texture_coords *= fastuidraw_imageAtlas_size_reciprocal.xyxy;

      t00 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.xz, color_layer));
      t10 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.yz, color_layer));
      t01 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.xw, color_layer));
      t11 = texture(fastuidraw_imageAtlasFiltered, vec3(texture_coords.yw, color_layer));

      linear_weight.x = weight_sums.y / (weight_sums.x + weight_sums.y);
      linear_weight.y = weight_sums.w / (weight_sums.z + weight_sums.w);

      image_color = mix(mix(t00, t10, linear_weight.x),
                        mix(t01, t11, linear_weight.x),
                        linear_weight.y);
    }

  color *= image_color;
}

void
fastuidraw_brush_repeat_window(inout uint shader_data_offset,
                               inout vec2 brush_location)
{
  fastuidraw_repeat_window wnd;

  shader_data_offset = fastuidraw_read_repeat_window(shader_data_offset, wnd);
  brush_location -= wnd.xy;
  brush_location = mod(brush_location, wnd.wh);
  brush_location += wnd.xy;
}

void
fastuidraw_brush_transformation_translation(inout uint shader_data_offset,
                                            inout vec2 brush_location)
{
  vec2 q;
  shader_data_offset = fastuidraw_read_transformation_translation(shader_data_offset, q);
  brush_location += q;
}

void
fastuidraw_brush_transformation_matrix(inout uint shader_data_offset,
                                       inout vec2 brush_location)
{
  mat2 m;
  shader_data_offset = fastuidraw_read_transformation_matrix(shader_data_offset, m);
  brush_location = m * brush_location;
}

void
fastuidraw_gl_brush_main(in uint sub_shader,
                         inout uint shader_data_offset,
                         inout vec2 brush_location,
                         inout vec4 color)
{
  fastuidraw_radial_gradient radial_gradient;
  vec2 q, delta_p;
  float delta_r, a, b, c, desc, t0, t1, recip_two_a, t;

  shader_data_offset = fastuidraw_read_radial_gradient(shader_data_offset, radial_gradient);
  q = brush_location - radial_gradient.start_pt;
  delta_p = radial_gradient.end_pt - radial_gradient.start_pt;
  delta_r = radial_gradient.end_r - radial_gradient.start_r;

  c = dot(q, q) - radial_gradient.start_r * radial_gradient.start_r;
  b = 2.0 * (dot(q, delta_p) - radial_gradient.start_r * delta_r);
  a = dot(delta_p, delta_p) - delta_r * delta_r;
  if(desc < 0.0)
    {
      color = vec4(0.0, 0.0, 0.0, 0.0);
    }
  else
    {
      desc = sqrt(abs(desc));
      recip_two_a = 0.5 / a;
      t0 = (-b + desc) * recip_two_a;
      t1 = (-b - desc) * recip_two_a;

      /* if both t0 and t1 are in range, then take the max
         if both t0 and t1 are not in range, then take max
         if only one of t0 and t1 are in range take that one.
      */

      /* G.x is 1 exactly when t0 is in range
         G.y is 1 exactly when t1 is in range
      */
      vec2 G;
      G = step(0.0, vec2(t0, t1)) * step(vec2(t0, t1), vec2(1.0, 1.0));
      t = (G.x == G.y) ? max(t0, t1) : dot(G, vec2(t0, t1));
      if((radial_gradient.flags & uint(fastuidraw_radial_gradient_repeat_mask)) != 0u)
        {
          t = fract(t);
        }
      t = radial_gradient.color_stop_sequence_xy.x + t * radial_gradient.color_stop_sequence_width;
      color *= fastuidraw_colorStopFetch(t, radial_gradient.color_stop_sequence_xy.y);
    }
}
